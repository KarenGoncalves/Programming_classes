{
  "hash": "3eab3b0f310c738907c21e450d9c3ff9",
  "result": {
    "markdown": "---\ntitle: \"Multiple sequence alignment and phylogenetic trees\"\nauthor: \"Karen Cristine Goncalves, Ph.D.\"\ndescription: \"3rd R class\"\nfontsize: 1.25em\nlinkcolor: grey\ncallout-appearance: simple\ncategories:\n  - R advanced\n  - Bioinformatics\nformat: \n  revealjs:\n    transition: none\n    theme: dark\n    scrollable: true\ndate: \"January 2024\"\nincremental: false\necho: true\nwarning: false\neval: true\n---\n\n\n## Packages\n\nBefore, we installed packages with the code below\n\n```{.r}\npkgs = c(\"rmarkdown\", \"tidyverse\", \"venn\")\npkgs.To.Install = which(! pkgs %in% installed.packages())\nif (length(pkgs.To.Install) != 0) install.packages(pkgs[pkgs.To.Install])\nfor (curPkg in pkgs) library(curPkg, character.only = T) \n```\n\nHowever, most packages for bioinformatics are not downloadable with a simple `install.packages`, as they are not stored in [CRAN](https://cran.r-project.org/), the basic website for R packages.\n\nInstead, they are in [Bioconductor](https://www.bioconductor.org/), and some are in specific github repositories (think about the [R_class_examples](https://github.com/KarenGoncalves/R_class_examples)).\n\n## Installing packages from other sources\n\n:::{.panel-tabset collapse=\"true\"}\n\n# Bioconductor packages\n\nFor these, we use the package BiocManager.\n\n```{.r}\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\npkgs.bioconductor = c(\"msa\", \"Biostrings\")\npkgs.To.Install = which(! pkgs.bioconductor %in% installed.packages())\nif (length(pkgs.To.Install) != 0) {\n\tBiocManager::install(pkgs.bioconductor[pkgs.To.Install])\t\n}\n```\n\n:::{.callout-tip}\nIn `BiocManager::install`, the `::` indicates that the function `install` comes from the package `BiocManager`.\n\nSo even if there is another package with the same function, R will know which one to use.\n:::\n\n# Github packages\n\n:::{.callout-tip}\n\nGithub is a website that has folders for each user, and each user may have multiple folders: one for each project. Example, in:\n\n- https://github.com/KarenGoncalves/R_class_examples\n\t- `KarenGoncalves/` is my folder in the website, in there I have over 20 folders, one for each project.\n\t- R_class_examples is one of them.\n:::\n\n```{.r}\nif (! \"devtools\" %in% installed.packages()) {\n\tinstall.packages(\"devtools\")\n}\n\nrepos.github = c(\"YuLab-SMU/ggmsa\")\npkgs.github = gsub(\".+/\", \"\", repos.github) # remove the folder name\npkgs.To.Install = which(! pkgs.github %in% installed.packages())\n\nif (length(pkgs.To.Install) != 0) {\n\t# To install the package, we need the folder + package name\n\tdevtools::install_github(repos.github[pkgs.To.Install])\t\n}\n```\n\n# Simplified install\n\nCopy the code below to load all the necessary packages. \n\nIn future, just come back here, copy the code below and change the list of packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::source_gist(\"https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978\")\n\ninstall_from_dif_sources(\n\tcran_packages = c(\"tidyverse\", \"tinytex\", \"patchwork\"),\n\tbioconductor_packages = c(\"Biostrings\", \"msa\", \"treeio\", \"ggtree\", \"ape\", \"seqinr\", \"phangorn\"),\n\tgithub_packages = \"YuLab-SMU/ggmsa\"\n)\n```\n:::\n\n\n\n:::{.callout-tip}\nThe link [https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978](https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978) contains the R script that creates functions to load the packages from different sources: CRAN (the typical source), Bioconductor and github.\n\nSo you just need to give the link to the function `devtools::source_gist()` and then you can use the function `install_from_dif_sources`\n:::\n\n:::\n\n## A note about classes\n\nR objects (the things in the environment tab) belong to different classes. The basic ones you already know:\n\n- vectors have one dimension and data inside has to be all the same type: character vector; numeric vector; factor vector\n- matrices: vectors, but with columns and rows\n- data.frames: table made of vectors (columns) of the same size\n- lists: anything goes! If the objects stored in it have names, you can access them like `list$object_name`, as if the object inside was a column of a table\n\n. . .\n\nTo check the class of an object you can use:\n\n```{.r}\nclass(object)\n```\n\n. . .\n\nA package may create it's own object class. Sometimes you need to convert an object from one class to another, like:\n\n::: {.cell}\n\n```{.r .cell-code}\n(numeric_vector <- 1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\nclass(numeric_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\n(character_vector <- as.character(numeric_vector)) # change class\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n```\n:::\n\n```{.r .cell-code}\nclass(character_vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n. . .\n\nSo, just remember that, if a function starts with `as.`, it is changing the class of the object.\n\n## Reading and writing fasta files\n\nIf you have protein sequences in a fasta file, copy it to your `inputs` folder, else use the following:  [Reductases.fasta](https://karengoncalves.github.io/Programming_classes/exampleData/Reductases.fasta)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To open a fasta file with multiple sequences, use the function readDNAStringSet() or readAAStringSet()\nfasta_input = \"https://karengoncalves.github.io/Programming_classes/exampleData/Reductases.fasta\" %>%\n\treadAAStringSet(format = \"fasta\")\nhead(fasta_input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAAStringSet object of length 6:\n    width seq                                               names               \n[1]   318 MATENKILILGPTGAIGRHIVWA...IEASEAYPDVTYTTADEYLNQFV IFR Medicago sativa\n[2]   330 MAAGFLFHMGSLPAIATVGHKSK...GEATKLYPEVGYTTVVEYMKRYV PILR2 Linum usita...\n[3]   598 MVGSIVGSNMAATDARFLSSNFG...VAHLPDKANNYLTPALSVLEKNT HC173 Arabidopsis...\n[4]   323 MTTGKGKILILGATGYLGKYMVK...EYLKICLVNPPKPKLATYAQPST IGS1 Petunia hybrida\n[5]   314 MEENGMKSKILIFGGTGYIGNHM...FTTIDELLDIFVHDPPPPASAAF EGS1 Ocimum basil...\n[6]   310 MVASEKSKILIIGGTGYIGKYLV...VEATELYPKVKYTTVDEFYNKFV IFRH Nicotiana gl...\n```\n:::\n\n```{.r .cell-code}\n# If you want to select just one or two sequences and export it, you can do:\nwriteXStringSet(fasta_input[1:3], \n\t\tfilepath = \"input_subset.fasta\", \n\t\tformat = \"fasta\")\n```\n:::\n\n\n## Multiple Sequence Alignment (MSA)\n\nMake things easy for yourself later, add the names of the parameters of each function so you know what you need to put next time.\n\n- There are 4 functions for MSA:\n\t- `msaClustalW` - ClustalW is a general purpose multiple alignment program for DNA or proteins. [<sup>1</sup>](http://www.clustal.org/download/clustalw_help.txt)\n\t\t- `cluster` parameter can be either Neighbor Joining (`\"nj\"`) or Unweighted Pair Group Method with Arithmetic mean (`\"upgma\"`)\n\t\t\t- Do not use `\"upgma\"` if you are on windows and your R version is 4.x (x being any number) - R crashes\n\t- `msaClustalOmega` - New MSA tool that uses seeded guide trees and HMM profile-profile techniques to generate alignments. Suitable for medium-large alignments.[<sup>2</sup>](https://www.ebi.ac.uk/Tools/msa/)\n\t\t- default `substitutionMatrix`: `\"Gonnet\"`; other options: `\"BLOSUM30\"`, `\"BLOSUM40`, `\"BLOSUM50\"`, `\"BLOSUM65\"` and `\"BLOSUM80\"`.\n\t- `msaMuscle` - Accurate MSA tool, especially good with proteins. Suitable for medium alignments.[<sup>2</sup>](https://www.ebi.ac.uk/Tools/msa/)\n\t\t- `cluster` parameter can be either NJ (`\"neighborjoining\"`) or UPGMA (`\"upgma\"`) - UPGMA gives better results [<sup>3</sup>](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC517706/)\n\t- `msa` - you can set the method with the argument `method` or just put the sequences and use the default (`\"Clustalw\"`) (other options: `\"ClustalOmega\"`, `\"Muscle\"`)\n\n- Add `verbose = T` so that the parameters used are printed to the screen and you can take note for your publications.\n\n## Running MSA\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The dataset used as example has 48 sequences, we will subset it for the alignment, selecting only 10\nfasta_for_alignment <- fasta_input[1:10]\n# use ?msa to know what you need to put in the function and what the default values are\nmyFirstAlignment <- msa(fasta_for_alignment, \n\t\t\tmethod = \"ClustalOmega\",\n\t\t\tverbose = T\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nparams: clustalo --R -o tempClustalOmega.aln --outfmt=clustal --seqtype=protein --force --gapopen=6.000000 --gapext=1.000000 --cluster-size=100 --iter=0 --output-order=tree-order\nusing Gonnet\n```\n:::\n\n```{.r .cell-code}\nmyFirstAlignment\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nClustalOmega 1.2.0 \n\nCall:\n   msa(fasta_for_alignment, method = \"ClustalOmega\", verbose = T)\n\nMsaAAMultipleAlignment with 10 rows and 780 columns\n     aln                                                   names\n [1] -------------------------...------------------------- 5BPOR Digitalis l...\n [2] -------------------------...----------ATYAQPST------- IGS1 Petunia hybrida\n [3] -------------------------...----------AAF------------ EGS1 Ocimum basil...\n [4] -------------------------...------------------------- PILR2 Linum usita...\n [5] -------------------------...------------------------- IFR Medicago sativa\n [6] -------------------------...------------------------- IFRH Nicotiana gl...\n [7] MVGSIVGSNMAATDARFLSSNFGNS...ELVAHLPDKANNYLTPALSVLEKNT HC173 Arabidopsis...\n [8] -------------------------...------------------------- ADH1 Catharanthus...\n [9] -------------------------...------------------------- ADH1 Euphorbia la...\n[10] -------------------------...------------------------- ADRC1 Arabidopsis...\n Con -------------------------...------------------------- Consensus \n```\n:::\n:::\n\n\n:::{.callout-note}\n\n# Visualizing the result\n\nJust calling the MSA result will not show the whole alignment. For that you can use `print()`\n\n```{.r}\nprint(myFirstAlignment, show = \"complete\", showConsensus = T)\n```\n:::\n\n## Use ggmsa for visualization\n\nTo see the alignment as a plot, we can use `ggmsa`.\n\n:::{.callout-note}\n\nWe need to change the type of object of the alignment result, as `ggmsa` only accepts `\"AAMultipleAlignment\"` objects\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The original result is of class MsaAAMultipleAlignment\nmyFirstAlignment2 <- myFirstAlignment # keep the original, make a copy to modify it\nclass(myFirstAlignment2) <-  \"AAMultipleAlignment\"\n\n# We will plot only a part of the alignment - from the AA 220 to the AA 250 - so it is visible \nggmsa(myFirstAlignment2, \n      start = 220, end = 250, \n      seq_name = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n\n```{.r .cell-code}\n# We can see also the consensus highlighted\nggmsa(myFirstAlignment2, \n      start = 220, end = 250, \n      seq_name = T, consensus_views = T)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-5-2.png){width=960}\n:::\n\n```{.r .cell-code}\n# Remove the # below if you want to save the figure\n#ggsave(\"First_alignment_consensus_220_250.tiff\")\n```\n:::\n\n\n## More `ggmsa` options\n\n:::{.panel-tabset}\n\n# Residue size\n\nWe can set the width of the characters (use `char_width = #`), so the residues are not so big\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggmsa(myFirstAlignment2, \n      start = 220, end = 250, \n      seq_name = T, char_width = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n# SeqLogo\n\nA seqlogo is a plot with letters on top of each other representing their frequency at each position in the alignment. The bigger a letter, the more frequent it is at a given position. \n\n- We can add this plot with `+ geom_seqlogo()`\n\t- you can use different color schemes with `geom_seqlogo(color = #)`<sup>1</sup>\n\t- you can set your color scheme with `geom_seqlogo(custom_color = data.frame)`<sup>1</sup>\n\t\n\n::: {.cell}\n\n```{.r .cell-code}\nggmsa(myFirstAlignment2, \n      start = 220, end = 250, \n      seq_name = T, char_width = 0.5) + \n\tgeom_seqlogo() \n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n\n```{.r .cell-code}\n# Note that the gaps are also represented in the seqlogo!\n```\n:::\n\n\n:::{.callout-tip}\n<sup>1</sup> Check the options with `?geom_seqlogo`\n:::\n\n# Consensus as bar graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggmsa(myFirstAlignment2, \n      start = 220, end = 250, \n      seq_name = T, char_width = 0.5) + \n\tgeom_seqlogo() +\n\tgeom_msaBar()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n\n:::\n\n## Make a phylogenetic tree\n\n**Learn what is necessary to make a tree, how to read it and what conclusions you can and cannot draw from them.**\n\n- Sequences used for the tree are the leaves/tips.\n- The point where the tree starts (the center if it is circular, or the first tip to separate from the rest of the tree) is the root\n- The lines drawing the tree are the branches/edges.\n- Going from the leaves to the root, the point where two branches connect is called a node\n\n\n## Compute the distance matrix\n\nWe will use `ape` and `seqinr` to create a tree from the alignment. But we need to, again, transform the type of object we got from the `msa`.\n\nThen we calculate a distance matrix.\n\n:::{.callout-tip}\nA distance matrix shows how different each sequence is from the others. It has as many rows as columns, since every sequence is compared to the others. \n\n- Its diagonal is all `0`s, since the difference between a sequence and itself is `0`. \n- The other rows and columns are values that indicate the amount of mismatches between two sequences. The greater the number, the less similar the two sequences are.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We need to first export the alignment and import it again to transform it \nmyFirstAlignment3 <- \n\tmyFirstAlignment %>% as.phyDat()\n\n# Then, we create a distance matrix\ndistance_alignment <- \n\tdist.ml(x = myFirstAlignment3, \n\t\tmodel = \"Blosum62\")\n```\n:::\n\n\n\n## Tree computation\n\nThen, we use the distance matrix to compute the tree, joining sequences most similar, then joining groups of sequences. Each method of computing will do this joining differently.\n\n:::{.panel-tabset}\n\n# nj\n\nThis function performs the neighbor-joining tree estimation of [Saitou and Nei (1987)](https://academic.oup.com/mbe/article/4/4/406/1029664?login=false).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnj(X = distance_alignment) %>% plot(main = \"ape::nj()\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n\n```{.r .cell-code}\nnj(X = distance_alignment) %>% \n\tplot(main = \"phangorn::NJ()\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-10-2.png){width=960}\n:::\n:::\n\n\n# bionj\n\nThis function performs the BIONJ algorithm of [Gascuel (1997)](https://academic.oup.com/mbe/article/14/7/685/1119804?login=false).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbionj(X = distance_alignment) %>% plot(main = \"ape::bionj\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n\n```{.r .cell-code}\nUNJ(distance_alignment) %>% plot(main = \"phangorn::UNJ\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-11-2.png){width=960}\n:::\n:::\n\n\n# fastme\n\nThe two FastME (fast minimum evolution) functions (balanced - bal - and ordinary least-squares - ols) perform the minimum evolution algorithm of [Desper and Gascuel (2002)](https://www.liebertpub.com/doi/10.1089/106652702761034136).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfastme.bal(distance_alignment) %>% plot(main = \"FastME BAL\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n\n```{.r .cell-code}\nfastme.ols(distance_alignment) %>% plot(main = \"FastME OLS\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-12-2.png){width=960}\n:::\n:::\n\n\n# UPGMA/WPGMA\n\n- UPGMA: uses the function `hclust` (hierarchical clustering) with `method = \"average\"`, then transforms the dendrogram into the class `phylo`. \n- WPGMA:  uses the function `hclust` with `method = \"mcquitty\"`, then transforms the dendrogram into the class `phylo`. \n\nRun `?hclust` then look the section \"Details\": the methods are explained with more details with references.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupgma(distance_alignment) %>% plot(main = \"UPGMA\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-13-1.png){width=960}\n:::\n\n```{.r .cell-code}\nwpgma(distance_alignment) %>% plot(main = \"WPGMA\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-13-2.png){width=960}\n:::\n:::\n\n\n:::\n\n## Customizing the plot\n\nWe can use dplyr to separate protein and species names.\n\n:::{.panel-tabset}\n\n# Get the tree\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupgma_tree <- upgma(distance_alignment)\n# We save the tree in a object so we can access the leaf labes with $tip.label\n```\n:::\n\n\n# Prepare the labels \n\nWe will use a function called `parse` to italicize only the species name. It evaluates the text and executes functions inside it! Example, in:\n\n`\"'TYDC '~italic('Narcissus pseudonarcissus')\"`\n\nThe texts `'TYDC '` and `'Narcissus pseudonarcissus'` (in italic) are joined by the symbol `~`.\n\nIn this case, the protein name has just letters and numbers and is at the start of the sequence name, followed by the species name. So we can use `gsub` to create the label we want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSeqnames_tree <- \n\tgsub(\"(\\\\w+) (.+)\", \n\t     \"'\\\\1 '~italic('\\\\2')\",\n\t     upgma_tree$tip.label)\nupgma_tree$tip.label <- Seqnames_tree\n```\n:::\n\n\n:::{.callout-note}\nCheck the result before plotting. See that your result looks like the example with `TYDC` above, as you need to use both double and single quotes.\n:::\n\n# Plot the labels\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(upgma_tree) +\n\t# use geom_tiplab to plot the seqnames\n\t# add parse = T so R executes the function inside the text\n\tgeom_tiplab(parse = T) +\n\txlim(c(0, 2)) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-16-1.png){width=960}\n:::\n\n```{.r .cell-code}\n\t# the upper x limit may change depending on the length of your labels, play around until you get the whole label but little empty space\n```\n:::\n\n\n:::\n\n## More customization\n\nLet's say you want to add bars marking different groups in a tree, like the vertical bars marking the clades in the figure below [(Figure 3 in Hori et al. 2006)](https://doi.org/10.1266/GGS.81.243):\n\n![](https://d3i71xaburhd42.cloudfront.net/82a7b788497724f0aee9b8b3ff45650c3489edfb/5-Figure3-1.png){width=40%}\n\n## Highlight important nodes\n\n:::{.panel-tabset}\n\n# Identify the nodes\n\nJust as we added the names of the leaves, we can add the names of the nodes with `geom_text(aes(label=node))`\n\nWe may need to play around with the `hjust`, which goes after `aes()`, inside `geom_text()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(upgma_tree) +\n\tgeom_text(aes(label = node), hjust = -.2) +\n\tgeom_tiplab(parse = T, hjust = -.15) +\n\txlim(c(0, 2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-17-1.png){width=960}\n:::\n:::\n\n\n# Mark groups\n\nIn our example tree, there are 2 main groups: nodes 12 and 13. We can use the function`geom_cladelabel` to mark each one\n\n:::{.callout-note}\nThere is also `geom_cladelab`, but you cannot change the color of the text with it\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(upgma_tree) +\n\t# we do not need the line below anymore\n\t#geom_text(aes(label = node), hjust = -.2) +\n\tgeom_tiplab(parse = T) +\n\tgeom_cladelabel(node = 12, label = \"Node 12\",\n\t\t\tcolor = \"red\", offset = 1) +\n\tgeom_cladelabel(node = 13, label = \"Node 13\",\n\t\t\tcolor = \"green4\", offset = 1,\n\t\t\tbarsize = 2) +\n\txlim(c(0, 2.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-18-1.png){width=960}\n:::\n:::\n\n\n# Highlight groups\n\nYou can draw a rectangle around the node and its branches using `geom_highlight`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(upgma_tree) +\n\t# we do not need the line below anymore\n\t#geom_text(aes(label = node), hjust = -.2) +\n\tgeom_tiplab(parse = T) +\n\tgeom_highlight(node = 12,\n\t\t       fill = \"red\") +\n\t# change the transparency of the rectangle with alpha\n\tgeom_cladelabel(node = 13, label = \"Node 13\",\n\t\t\tcolor = \"green4\", offset = 1,\n\t\t\tbarsize = 2) +\n\txlim(c(0, 2.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-19-1.png){width=960}\n:::\n:::\n\n\n:::\n\n## Statistical support\n\nThe statistical support on phylogenetic trees is calculated with bootstrap. In simple terms, bootstrap is repetition. In more complicated terms, the tree computation (including the calculation of the distance matrix) is repeated *n times*<sup>`1`</sup>, and the result shows the proportion of times the node appeared.\n\nIf out of 1000 times, a given group appears 100 times, its support is 10%.\n\n<sup>`1`</sup> n is determined by the number of sequences you are working with. \n\n- n is the number of times the calculation was repeated, so it includes the first time. That is why you may see it reported as 'bootstrap was performed with 999 replicates' (plus the original tree calculation, you get 1&nbsp;000 replicates)\n- Although more is better, using n=10&nbsp;000 for a tree of 10 sequences is overkill and may take too much time to calculate.\n- The most typical n used (for < 50 sequences in a tree) is 999\n\n## Bootstrap support\n\nLet's consider that we want to use `upgma` to calculate our tree and we want to calculate the support of the branches.\n\n:::{.panel-tabset}\n\n# Computation\n\nWe use the function `bootstrap.phyDat` the same way we use `sapply`: using this dataset, perform this set of functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupgma_tree <- myFirstAlignment3 |>\n\tdist.ml() |> upgma()\nbs_upgma <- bootstrap.phyDat(\n\tmyFirstAlignment3, \n\tbs = 100, \\(x){\n\t\tdist.ml (x) |> upgma()\n\t})\n\nbs_plot <- plotBS(upgma_tree, bs_upgma)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-20-1.png){width=960}\n:::\n\n```{.r .cell-code}\n# The data stored in bs_plot is exactly what we need for ggtree\n```\n:::\n\n\n# Tree preparation\n\nSince this is a new file, we need to correct the sequence names again.\n\nWe also set a threshold for bootstrap. Only values passing the threshold are shown.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbs_plot2 <- bs_plot\n\n# We correct the sequence names\nSeqnames_tree <- \n\tgsub(\"(\\\\w+) (.+)\", \n\t     \"'\\\\1 '~italic('\\\\2')\",\n\t     bs_plot$tip.label)\nbs_plot2$tip.label <- Seqnames_tree\n\n# Bootstrap threshold\nbs_threshold <- 50\nbs_plot2$node.label <- \n\tifelse(bs_plot$node.label < bs_threshold,\n\t       \"\", bs_plot$node.label)\n```\n:::\n\n\n# Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggtree(bs_plot2) +\n\tgeom_tiplab(parse = T) +\n\tgeom_highlight(node = 12,\n\t\t       fill = \"red\") +\n\tgeom_nodelab(nudge_x = 0.03) +\n\t# we use nudge_x to move the label away from the branches\n\txlim(c(0, 1.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-22-1.png){width=960}\n:::\n:::\n\n\n# Export\n\nWe export the trees to a newick (.nwk) file\n\nThis format is readable by any program working with trees. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.tree(bs_upgma, file = \"bootstrap_upgma_trees.nwk\")\n```\n:::\n\n\n:::\n\n## Resources\n\n- [Multiple sequence alignment in R - msa](https://www.bioconductor.org/packages/release/bioc/vignettes/msa/inst/doc/msa.pdf)\n- [ape: phylogenetic trees](https://cran.r-project.org/web/packages/ape/vignettes/DrawingPhylogenies.pdf)\n- [ggmsa](https://yulab-smu.top/ggmsa/)\n- [ggtree](https://bioconnector.github.io/workshops/r-ggtree.html)\n- [phangorn](https://cran.r-project.org/web/packages/phangorn/vignettes/Trees.html)\n\n## Aminoacid substitution models for `dist.ml()`\n\n- ['BLOSUM62'](https://www.nature.com/articles/nbt0804-1035)\n- ['WAG'](doi.org/10.1093/oxfordjournals.molbev.a003851)\n- ['JTT'](http://dx.doi.org/10.1093/bioinformatics/8.3.275)\n- ['LG'](http://dx.doi.org/10.1093/molbev/msn067)\n- ['Dayhoff'](http://profs.scienze.univr.it/~liptak/ALBioinfo/2011_2012/files/pam1.pdf)\n- ['cpREV'](http://dx.doi.org/10.1007/s002399910038)\n- ['VT'](http://dx.doi.org/10.1089/10665270050514918)\n- ['rtREV'](http://dx.doi.org/10.1007/s00239-001-2304-y)\n- ['Dayhoff_DCMut'and 'JTT_DCMut'](http://dx.doi.org/10.1093/molbev/msi005)\n\n\n\nSpecific\n\n- Mitochondrial  \n\t- ['mtmam'](http://dx.doi.org/10.1093/oxfordjournals.molbev.a025888)\n\t- ['mtzoa'](https://doi.org/10.1016/j.ympev.2009.01.011)\n\t- ['mtREV24'](http://stat.sys.i.kyoto-u.ac.jp/titech/class/doc/csm96.pdf)\n\t- Arthropoda:  ['mtart'](http://dx.doi.org/10.1093/molbev/msl136)\n\t- HIV:  ['HIVb' and 'HIVw'](http://dx.doi.org/10.1007/s00239-001-2304-y)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}