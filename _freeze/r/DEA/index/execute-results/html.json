{
  "hash": "f7ed43c8d35b4d39e9db8f841e396283",
  "result": {
    "markdown": "---\ntitle: \"Differential expression analysis\"\nauthor: \"Karen Cristine Goncalves, Ph.D.\"\ndescription: \"5th R class - transcriptomics sessions\"\nlinkcolor: grey\ncallout-appearance: simple\ncategories:\n  - R advanced\n  - \"Differential gene expression\"\n  - Omics\n  - Transcriptomics\nformat: \n  revealjs:\n    fontsize: 1.5em\n    transition: none\n    theme: dark\n    scrollable: true\ndate: \"21 March 2024\"\nincremental: false\necho: true\nwarning: false\neval: true\ndraft: true\neditor_options: \n  chunk_output_type: console\n---\n\n\n<!-- <style> -->\n\n<!-- /* code font size */ -->\n<!-- code.sourceCode { -->\n<!--   font-size: 1em; -->\n<!-- } -->\n\n<!-- </style> -->\n\n\n::: {.cell}\n\n:::\n\n\n## The dataset\n\nThe input file is the table [Arabidopsis_counts.csv](../../exampleData/Arabidopsis_counts.csv). \n\n\n::: {.cell}\n\n:::\n\n\n```{.r}\ncounts = read.csv(\"https://karengoncalves.github.io/Programming_classes/exampleData/Arabidopsis_counts.csv\",\n                  header = T, row.names = 1)\n```\n\nThis file has 12 columns (3 samples * 4 replicates) and 32833 rows (one per gene).\n\nSamples are aerial tissue of _Arabidopsis thaliana_ ecotype Col-0, harvested at 14 days post germination, with Basta (glyphosate) resistance gene and:\n\n- Control: GFP under the 35S promoter\n- Mlp37347 and Mlp124499: a candidate effector gene (*Mlp37347* or *Mlp124499* from the fungus *Melampsora larici-populina*) tagged with GFP under the 35S promoter\n\n\n## Create design table - part 1\n\nThe design table explains to R what each column is: \n\n- Control or treatment\n- Wild-type or mutant\n- From place X or place Y. \n- Harvested at time 0, 1, 2, 3...\n\nBasically, you need first one column with the rows containing the same values as the column names of the count matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesign_matrix = data.frame(Replicates = names(counts))\n```\n:::\n\n\nThen, you need one (or more) columns that indicate the sample that replicate comes from.\n\n## Create design table - part 2\n\nNote that you separate things in the columns, eg. you harvested different tissues at different time points, you would need a design table with three columns: `Replicates`, `tissue_type` and `Time_point`.\n\nIn this case, the genotypes of the plants is part of their name (just remove the `_#` to get it):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndesign_matrix = design_matrix %>%\n  mutate(Genotype = gsub(\"_\\\\d+$\", \"\", \n                         # replace the underscore and digits at the end of the text \n                         # with nothing\n                         Replicates))\n\nhead(design_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Replicates Genotype\n1  Control_1  Control\n2  Control_2  Control\n3  Control_3  Control\n4  Control_4  Control\n5 Mlp37347_1 Mlp37347\n6 Mlp37347_2 Mlp37347\n```\n:::\n:::\n\n\n## Filtering read counts\n\nNot all genes in a genome will be expressed in a study (even one with many conditions and developmental stages), since some need very specific conditions to be expressed. Check for example the gene AT1G01046 (row 5)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts[5,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Control_1 Control_2 Control_3 Control_4 Mlp37347_1 Mlp37347_2\nAT1G01046         0         0         0         0          0          0\n          Mlp37347_3 Mlp37347_4 Mlp124499_1 Mlp124499_2 Mlp124499_3 Mlp124499_4\nAT1G01046          0          0           0           0           0           0\n```\n:::\n:::\n\n\n:::{.panel-tabset}\n\n# Simple filter\nWe can clean up the data, removing genes that are not expressed ever in our experiment. In theory, genes not expressed will have read `count == 0` in all samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenes_not_expressed = rowSums(counts) == 0\ngenes_not_expressed %>% which() %>% length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5632\n```\n:::\n\n```{.r .cell-code}\n# We keep only rows that are FALSE in the variable genes_not_expressed\ncounts_filtered = counts[ !genes_not_expressed, ]\n```\n:::\n\n\n# Complex filter\n\nAnother way of filtering weakly expressed genes would be with the functions DAFS from the [\"KarenGoncalves/CustomSelection\"](https://github.com/KarenGoncalves/CustomSelection) package. \n\nThe function gives you the minimum expression level accepted per replicate (based on the sequencing depth), from there you can filter out the genes that are expressed at a level lower than that threshold.\n\nYou will need the count matrix and a named vector with the length of each gene.\n\n```{.r}\n# The first thing you do convert the read counts to TPM (transcripts per million):\ntpm = Counts_to_tpm(counts=counts, featureLength=length)[[1]]\n\n# Then you calculate the minimum expression level\ncutv = DAFS(tpm=tpm) # value given as log2 TPM\n# Calculate the mean minimum expression level and convert it to TPM\nmin_expr_level = mean(cutv) ^ 2 \n\n# Now to filter the weakly expressed genes,\n# Remove the ones that are expressed below the min_expr_level\nexpressed_genes = apply(tpm, 1, mean) > min_expr_level\ncounts_filtered = countsData[, expressed_genes]\n```\n\n:::\n\n\n## DESeq2 - main analysis\n\nNow that you have the filtered counts matrix and the design table, you can run DESeq2 by first creating the dataset object then running the function DESeq.\n\nPay attention to always put your control samples at the beginning of the count matrix and the design table, as the first sample is taken as the control.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeseq_dataset = DESeqDataSetFromMatrix(\n  countData = counts_filtered,\n  colData = design_matrix, # colData means data about the columns of the count matrix\n  design = ~Genotype # basically: expression in function of the genotype\n) %>% DESeq()\n```\n:::\n\n\n## DESeq2 - note on designs\n\nWe used the design `~Genotype`, which is similar to taking the expression level for each gene and compare it between the different genotypes. \n\nIt takes the first level of the factor `Genotype` as the control. \n\nBecause of this, the comparisons we are able to make are only `Genotype_x` vs `Genotype_Control`, we cannot compare `Genotype_x` against `Genotype_y`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultsNames(deseq_dataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Intercept\"                     \"Genotype_Mlp124499_vs_Control\"\n[3] \"Genotype_Mlp37347_vs_Control\" \n```\n:::\n:::\n\n\n## DESeq2 - note (2) on designs\n\nIf we want to make all possible pairwise comparisons, we need to add a `0` to the design function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeseq_dataset2 = DESeqDataSetFromMatrix(\n  countData = counts_filtered,\n  colData = design_matrix, \n  design = ~0 + Genotype # basically: expression in function of the genotype\n) %>% DESeq()\n\nresultsNames(deseq_dataset2) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"GenotypeControl\"   \"GenotypeMlp124499\" \"GenotypeMlp37347\" \n```\n:::\n:::\n\n\n## DESeq2 - note (3) on designs\n\nIf your samples are defined by 2 factors, say `Genotype` and `Age` (both present int the `design_matrix` data.frame), you can set the design to either:\n\n- `~Genotype + Age` - you will be able to compare `genotype1` against `genotype2`, and `age1` against `age2`, but not `genotype1_age1` against `genotype1_age2`\n- `~Genotype + Age + Genotype:Age` - models the differences between genotypes at the first `Age` value, the differences at different time points (grouping all genotypes), and genotype-specific differences across the different levels of `Age`.\n\n## DESeq2 - note (4) on designs\n\nIf you have a time series experiment, then you need to add a \"reduced\" design in the `DESeq` function: \n  \n```{.r}\ndeseq_dataset = DESeqDataSetFromMatrix(\n  countData = counts_filtered,\n  colData = design_matrix, \n  design = ~Genotype + Age + Genotype:Age\n) %>% \n  DESeq(test=\"LRT\", # likelyhood ratio test\n        reduced = ~ Genotype + Age)\n```\n\n## DESeq2 results\n\nNow the main part of the analysis is done, to access the results and inform the type of stats you want performed, you use the function `results`. \n\nHowever, you need to inform `R` which comparison you want to evaluate each time. To see the options, you can run `resultsNames()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultsNames(deseq_dataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Intercept\"                     \"Genotype_Mlp124499_vs_Control\"\n[3] \"Genotype_Mlp37347_vs_Control\" \n```\n:::\n\n```{.r .cell-code}\nname_result = resultsNames(deseq_dataset)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_DESeq2 = list()\nresults_DESeq2[[ name_result[2] ]] = \n  results(deseq_dataset, \n          name = name_result[2],\n          pAdjustMethod = \"BH\")@listData %>%\n  as_tibble() %>%\n  mutate(Gene_name = rownames(counts_filtered),\n         State = case_when(\n           log2FoldChange < 2 ~ \"Down-regulated\",\n           log2FoldChange > 2 ~ \"Up-regulated\",\n           .default = \"equal\"\n         ))\n\nhead(results_DESeq2[[ name_result[2] ]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n  baseMean log2FoldChange lfcSE   stat     pvalue     padj Gene_name State      \n     <dbl>          <dbl> <dbl>  <dbl>      <dbl>    <dbl> <chr>     <chr>      \n1     73.8         -1.28  0.329 -3.89   0.0000989  0.00302 AT1G01010 Down-regul…\n2    149.          -0.296 0.209 -1.42   0.156      0.544   AT1G01020 Down-regul…\n3     71.1         -0.709 0.248 -2.86   0.00430    0.0562  AT1G01030 Down-regul…\n4    800.          -0.122 0.216 -0.563  0.573      0.884   AT1G01040 Down-regul…\n5    482.          -0.308 0.330 -0.933  0.351      0.759   AT1G01050 Down-regul…\n6   3353.          -1.38  0.624 -2.21  NA         NA       AT1G01060 Down-regul…\n```\n:::\n:::\n\n\n. . .\n\n- How many genes are deregulated in this comparison?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_DESeq2[[ name_result[2] ]]  %>%\n  filter(padj < 0.01) %>%\n  dplyr::count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n      n\n  <int>\n1   934\n```\n:::\n:::\n\n\n. . .\n\n- How many genes are up and how many down-regulated?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults_DESeq2[[ name_result[2] ]] %>%\n  filter(padj < 0.01) %>%\n  group_by(State) %>%\n  dplyr::count()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n# Groups:   State [2]\n  State              n\n  <chr>          <int>\n1 Down-regulated   807\n2 Up-regulated     127\n```\n:::\n:::\n\n\n\n## Resources\n\n- ARTICLES\n    - [ideal: an R/Bioconductor package for interactive differential expression analysis](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-020-03819-5)\n- TUTORIALS\n    - [Angus - DEA and visualization](https://angus.readthedocs.io/en/2019/diff-ex-and-viz.html)\n    - [COMBINE Australia - RNASeq](https://combine-australia.github.io/RNAseq-R/06-rnaseq-day1.html)\n    - [Griffith lab - DEA with DESeq2](https://genviz.org/module-04-expression/0004/02/01/DifferentialExpression/)\n    - [Love, Anders and Huber - DESeq2](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)\n    ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}