pattern = ".bam$")
)
baiFiles <- paste0(bamFiles, ".bai")
baseNames <- gsub("_Aligned.sortedByCoord.out.bam", "",
basename(bamFiles))
TxDbPath <- paste0(inDir, "Arabidopsis_TxDb.RData")
outPutDir <- "/sites/Programming_classes/exampleData/"
# Now we load the RData
# This line tells R where the alignment files for the sample are and how much of them to read at a time
bfl <- BamFileList(bamFiles,
baiFiles,
yieldSize=200000)
overlaps <- summarizeOverlaps(
features = tx, # genes' coordinates
reads = bfl, # bam and bai files
mode = "Union",
# mode can be also "IntersectStrict" or "IntersectNotEmpty"
singleEnd = F, fragments = T,
ignore.strand = T
)
load(TxDbPath)
inDir = "/sites/Programming_classes/exampleData/"
bamFiles <- paste0(inDir,
list.files(path = inDir,
pattern = ".bam$")
)
baiFiles <- paste0(bamFiles, ".bai")
baseNames <- gsub("_Aligned.sortedByCoord.out.bam", "",
basename(bamFiles))
TxDbPath <- paste0(inDir, "Arabidopsis_TxDb.RData")
outPutDir <- "/sites/Programming_classes/exampleData/"
load(TxDbPath)
inDir = "/sites/Programming_classes/exampleData/"
bamFiles <- paste0(inDir,
list.files(path = inDir,
pattern = ".bam$")
)
baiFiles <- paste0(bamFiles, ".bai")
baseNames <- gsub("_Aligned.sortedByCoord.out.bam", "",
basename(bamFiles))
TxDbPath <- paste0(inDir, "Arabidopsis_TxDb.RData")
outPutDir <- "/sites/Programming_classes/exampleData/"
load(TxDbPath)
# Now we load the RData
# This line tells R where the alignment files for the sample are and how much of them to read at a time
bfl <- BamFileList(bamFiles,
baiFiles,
yieldSize=200000)
inDir = "/sites/Programming_classes/exampleData/"
bamFiles <- paste0(inDir,
list.files(path = inDir,
pattern = ".bam$")
)
baiFiles <- paste0(bamFiles, ".bai")
baseNames <- gsub("_Aligned.sortedByCoord.out.bam", "",
basename(bamFiles))
TxDbPath <- paste0(inDir, "Arabidopsis_TxDb.RData")
outPutDir <- "/sites/Programming_classes/exampleData/"
load(TxDbPath)
# Now we load the RData
# This line tells R where the alignment files for the sample are and how much of them to read at a time
bfl <- BamFileList(bamFiles,
baiFiles,
yieldSize=200000)
overlaps <- summarizeOverlaps(
features = tx, # genes' coordinates
reads = bfl, # bam and bai files
mode = "Union",
# mode can be also "IntersectStrict" or "IntersectNotEmpty"
singleEnd = F, fragments = T,
ignore.strand = T
)
# We save this result, so if there is an issue with the rest of the code, the heavy part of the program gets saved before R stops
save(overlaps, file = paste0(outPutDir, "overlaps.RData"))
<p style="color: red">**The things shown in this class are for true mappings onto reference genomes.**</p>
CustomSelection::sample_counts
CustomSelection::sample_counts %>% names
names(CustomSelection::sample_counts)
exp(0.5)
2^0.5
CustomSelection::sample_counts
library(tidyverse)
CustomSelection::sample_counts %>% write.csv(file = "exampleData/Arabidopsis_counts.csv", append = F, quote = F,row.names = T, col.names = T)
CustomSelection::sample_counts %>% head()
CustomSelection::sample_counts %>% dim
CustomSelection::sample_counts %>% head
CustomSelection::sample_counts[5,]
genes_not_expressed = which(rowSums(counts) == 0)
counts = CustomSelection::sample_counts
genes_not_expressed = which(rowSums(counts) == 0)
length(genes_not_expressed)
genes_not_expressed = rowSums(counts) == 0
genes_not_expressed %>% which() %>%length()
# We keep only rows that are FALSE in the variable genes_not_expressed
non_zero_counts = counts[!genes_not_expressed,]
myFirstInput = read.delim("https://karengoncalves.github.io/Programming_classes/exampleData/Class1_exampleData.txt", header = T)
View(myFirstInput)
letters
(myLetters = as.factor(letters))
as.numeric(myLetters)
as.numeric(letters)
myPlantGrowth = head(PlantGrowth)
# Use the name of the table, and [], inside put the number of the row followed by ","
myPlantGrowth[1,] # prints the first row
# See and set rownames with the function rownames
rownames(myPlantGrowth)
# Byt surrounding the code below in (), we both assign the values to the variable AND see the result
(rownames(myPlantGrowth) = 6:1) # creates a sequence starting from 30 and ending in 1
myPlantGrowth = head(PlantGrowth)
# Use the name of the table, and [], inside put the number of the row followed by ","
myPlantGrowth[1,] # prints the first row
# See and set rownames with the function rownames
rownames(myPlantGrowth)
rownames(myPlantGrowth) = 6:1 # creates a sequence starting from 30 and ending in 1
rownames(myPlantGrowth)
library(ggmsa)
?ggmsa
fasta <- system.file("extdata", "sample.fasta", package = "ggmsa")
ggmsa(fasta, color = "CN6")
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse", "tinytex", "patchwork"),
bioconductor_packages = c("Biostrings", "msa", "treeio", "ggtree", "ape", "seqinr", "phangorn"),
github_packages = "YuLab-SMU/ggmsa"
)
(numeric_vector <- 1:10)
class(numeric_vector)
(character_vector <- as.character(numeric_vector)) # change class
class(character_vector)
# To open a fasta file with multiple sequences, use the function readDNAStringSet() or readAAStringSet()
fasta_input = "../../exampleData/Reductases.fasta" %>%
readAAStringSet(format = "fasta")
head(fasta_input)
# The dataset used as example has 48 sequences, we will subset it for the alignment, selecting only 10
fasta_for_alignment <- fasta_input[1:10]
# use ?msa to know what you need to put in the function and what the default values are
myFirstAlignment <- msa(fasta_for_alignment,
method = "ClustalOmega",
verbose = T
)
myFirstAlignment
# The original result is of class MsaAAMultipleAlignment
myFirstAlignment2 <- myFirstAlignment # keep the original, make a copy to modify it
class(myFirstAlignment2) <-  "AAMultipleAlignment"
# We will plot only a part of the alignment - from the AA 220 to the AA 250 - so it is visible
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T)
# We can see also the consensus highlighted
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, consensus_views = T)
# Remove the # below if you want to save the figure
#ggsave("First_alignment_consensus_220_250.tiff")
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5)
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5) +
geom_seqlogo()
# Note that the gaps are also represented in the seqlogo!
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5) +
geom_seqlogo() +
geom_msaBar()
#You can change it by setting:
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
color = "Clustal") # use the option color
# To see the legend, you only need to ask
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
color = "Chemistry_AA", # use the option color
show.legend = T)
# To see the legend, you only need to ask
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
color = "Chemistry_AA", # use the option color
show.legend = T) +
labs(fill = "", color = "")
install_from_dif_sources(cran_packages =
c("RColorBrewer", "pals"))
install_from_dif_sources(cran_packages =
c("RColorBrewer", "pals"))
my_pal <- colorRampPalette(rev(brewer.pal(n = 9, name = "Reds")))
my_custom <- data.frame(names = c(LETTERS[1:26],"-"),
color = my_pal(27),
stringsAsFactors = FALSE)
head(my_custom)
pals::pal.bands(my_cutstom$color)
install_from_dif_sources(cran_packages =
c("RColorBrewer", "pals"))
my_pal <- colorRampPalette(rev(brewer.pal(n = 9, name = "Reds")))
my_custom <- data.frame(names = c(LETTERS[1:26],"-"),
color = my_pal(27),
stringsAsFactors = FALSE)
head(my_custom)
pals::pal.bands(my_custom$color)
# What are the palettes available?
brewer.pal.info
RColorBrewer::display.brewer.all()
my_pal <- brewer.pal(n = 9, name = "Reds") %>%
rev() %>% colorRampPalette()
my_custom <-
data.frame(names = c(LETTERS[1:26],"-"),
# names have a;; possible letters in the alignment
# including the gaps
color = my_pal(27),
# We take 27 colors from the palette
stringsAsFactors = FALSE)
head(my_custom)
pals::pal.bands(my_custom$color)
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
custom_color = my_custom, # use the option custom_color
show.legend = T) +
labs(fill = "", color = "")
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
font = NULL) +
geom_seqlogo() +
geom_msaBar()
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
font = NULL, show.legend = T) +
geom_seqlogo() +
geom_msaBar()
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
font = NULL, show.legend = T) +
geom_seqlogo()
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
font = NULL, show.legend = T) +
geom_seqlogo() +
labs(fill = "", color = "")
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
font = NULL, show.legend = T,
border = NULL) +
geom_seqlogo() +
labs(fill = "", color = "")
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
font = NULL, show.legend = T,
border = "white") +
geom_seqlogo() +
labs(fill = "", color = "")
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, char_width = 0.5,
font = NULL, show.legend = T) +
geom_seqlogo() +
labs(fill = "", color = "")
RColorBrewer::display.brewer.all(colorblindFriendly = T)
a = RColorBrewer::display.brewer.all()
install_from_dif_sources(cran_packages =
c("RColorBrewer", "pals"))
# What are the palettes available?
brewer.pal.info
# you can check the palette visually with
#display.brewer.pal(n, name)
# where n is the number of colors the palette has
# and name is the name of the palette
install_from_dif_sources(cran_packages =
c("RColorBrewer", "pals"))
# What are the palettes available?
brewer.pal.info
# you can check the palette visually with
#display.brewer.pal(n, name)
# where n is the number of colors the palette has
# and name is the name of the palette
display.brewer.pal(11, "BrBG")
quarto::quarto_render()
---
title: "Multiple sequence alignment and phylogenetic trees"
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse", "tinytex", "patchwork"),
bioconductor_packages = c("Biostrings", "msa", "treeio", "ggtree", "ape", "seqinr", "phangorn"),
github_packages = "YuLab-SMU/ggmsa"
)
# To open a fasta file with multiple sequences, use the function readDNAStringSet() or readAAStringSet()
fasta_input = "../../exampleData/Reductases.fasta" %>%
readAAStringSet(format = "fasta")
head(fasta_input)
# The dataset used as example has 48 sequences, we will subset it for the alignment, selecting only 10
fasta_for_alignment <- fasta_input[1:10]
# use ?msa to know what you need to put in the function and what the default values are
myFirstAlignment <- msa(fasta_for_alignment,
method = "ClustalOmega",
verbose = T
)
myFirstAlignment
# The original result is of class MsaAAMultipleAlignment
myFirstAlignment2 <- myFirstAlignment # keep the original, make a copy to modify it
class(myFirstAlignment2) <-  "AAMultipleAlignment"
# We will plot only a part of the alignment - from the AA 220 to the AA 250 - so it is visible
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T)
# We can see also the consensus highlighted
ggmsa(myFirstAlignment2,
start = 220, end = 250,
seq_name = T, consensus_views = T)
# Remove the # below if you want to save the figure
#ggsave("First_alignment_consensus_220_250.tiff")
---
title: "Multiple sequence alignment and phylogenetic trees"
quarto::quarto_render()
quarto::quarto_preview()
library(quarto)
quarto_inspect()
169+108+605+177+243
169+42+96+277
42+96+79+108
243+79+277+96
quarto::quarto_render()
CustomSelection::sample_counts
#| echo: false
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse"),
bioconductor_packages = c("Biostrings", "DESeq2"),
github_packages = "KarenGoncalves/CustomSelection"
)
library(DESeq2)
#| echo: false
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse"),
bioconductor_packages = c("Biostrings", "DESeq2"),
github_packages = "KarenGoncalves/CustomSelection"
)
counts = CustomSelection::sample_counts
design_matrix = data.frame(Replicates = names(counts))
design_matrix = design_matrix %>%
mutate(Genotype = gsub("_\\d+$", "",
# replace the underscore and digits at the end of the text
# with nothing
Replicates))
head(design_matrix)
counts[5,]
genes_not_expressed = rowSums(counts) == 0
genes_not_expressed %>% which() %>% length()
# We keep only rows that are FALSE in the variable genes_not_expressed
counts_filtered = counts[ !genes_not_expressed, ]
deseq_dataset = DESeqDataSetFromMatrix(
countData = counts_filtered,
colData = design_matrix, # colData means data about the columns of the count matrix
design = ~Genotype # basically: expression in function of the genotype
) %>% DESeq()
#| echo: false
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse"),
bioconductor_packages = c("Biostrings", "DESeq2"),
github_packages = "KarenGoncalves/CustomSelection"
)
#| echo: false
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse"),
bioconductor_packages = c("Biostrings", "DESeq2"),
github_packages = "KarenGoncalves/CustomSelection"
)
#| echo: false
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse"),
bioconductor_packages = c("Biostrings", "DESeq2"),
github_packages = "KarenGoncalves/CustomSelection"
)
counts = read.csv("https://karengoncalves.github.io/Programming_classes/exampleData/Arabidopsis_counts.csv",
header = T, row.names = 1)
head(counts)
# Chunk 1
#| echo: false
#| output: false
#| warning: false
devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")
install_from_dif_sources(
cran_packages = c("tidyverse"),
bioconductor_packages = c("Biostrings", "DESeq2"),
github_packages = "KarenGoncalves/CustomSelection"
)
# Chunk 2
counts = CustomSelection::sample_counts
# Chunk 3
design_matrix = data.frame(Replicates = names(counts))
# Chunk 4
design_matrix = design_matrix %>%
mutate(Genotype = gsub("_\\d+$", "",
# replace the underscore and digits at the end of the text
# with nothing
Replicates))
head(design_matrix)
# Chunk 5
counts[5,]
# Chunk 6
genes_not_expressed = rowSums(counts) == 0
genes_not_expressed %>% which() %>% length()
# We keep only rows that are FALSE in the variable genes_not_expressed
counts_filtered = counts[ !genes_not_expressed, ]
# Chunk 7
deseq_dataset = DESeqDataSetFromMatrix(
countData = counts_filtered,
colData = design_matrix, # colData means data about the columns of the count matrix
design = ~Genotype # basically: expression in function of the genotype
) %>% DESeq()
# Chunk 8
resultsNames(deseq_dataset)
# Chunk 9
deseq_dataset2 = DESeqDataSetFromMatrix(
countData = counts_filtered,
colData = design_matrix,
design = ~0 + Genotype # basically: expression in function of the genotype
) %>% DESeq()
resultsNames(deseq_dataset2)
# Chunk 10
resultsNames(deseq_dataset)
name_result = resultsNames(deseq_dataset)
# Chunk 11
# Remove the first element of name_result, since it is just the intercept
results_DESeq2 <-
lapply(name_result[-1], \(comparison) {
results(deseq_dataset,
name = name_result[2],
pAdjustMethod = "BH")@listData %>%
as_tibble() %>%
mutate(
# We need to add the gene names
Gene_name = rownames(counts_filtered),
# We classify the genes by deregulation
State = case_when(
log2FoldChange < 2 ~ "Down-regulated",
log2FoldChange > 2 ~ "Up-regulated",
.default = "equal"),
# Indicate from which comparison the data comes from
Contrast = comparison
)
}) %>%
list_rbind()
head(results_DESeq2)
# Chunk 12
results_DESeq2  %>%
filter(padj < 0.01) %>%
group_by(Contrast) %>%
dplyr::count()
results_DESeq2  %>%
filter(padj < 0.01)
results_DESeq2 %>%
filter(padj < 0.01) %>%
group_by(Contrast, State) %>%
dplyr::count()
# Remove the first element of name_result, since it is just the intercept
results_DESeq2 <-
lapply(name_result[-1], \(comparison) {
results(deseq_dataset,
name = comparison,
pAdjustMethod = "BH")@listData %>%
as_tibble() %>%
mutate(
# We need to add the gene names
Gene_name = rownames(counts_filtered),
# We classify the genes by deregulation
State = case_when(
log2FoldChange < 2 ~ "Down-regulated",
log2FoldChange > 2 ~ "Up-regulated",
.default = "equal"),
# Indicate from which comparison the data comes from
Contrast = comparison
)
}) %>%
list_rbind()
head(results_DESeq2)
results_DESeq2  %>%
filter(padj < 0.01) %>%
group_by(Contrast) %>%
dplyr::count()
results_DESeq2 %>%
filter(padj < 0.01) %>%
group_by(Contrast, State) %>%
dplyr::count()
install.packages("kableExtra")
install.packages("openxlsx")
